<!--
 * @Descripttion: 
 * @Author: chalan630
 * @Date: 2020-01-11 23:43:39
 * @LastEditTime : 2020-01-13 16:50:48
 -->
## 编码与解码

- ASCII 占1个字节，只支持英文
- GB2312 占2个字节，支持6700+汉字
- GBK GB2312的升级版，支持21000+汉字
- Shift-JIS 日本字符
- ks_c_5601-1987 韩国编码
- TIS-620 泰国编码

由于每个国家都有自己的字符，所以其对应关系也涵盖了自己国家的字符，但是以上编码都存在局限性，即：仅涵盖本国字符，无其他国家字符的对应关系。应运而生出现了万国码，他涵盖了全球所有的文字和二进制的对应关系。
- Unicode 2-4字节 已经收录136690个字符，并还在一直不断扩张中...

Unicode解决了字符和二进制的对应关系，但是使用unicode表示一个字符，太浪费空间。例如：利用unicode表示“Python”需要12个字节才能表示，比原来ASCII表示增加了1倍。  
由于计算机的内存比较大，并且字符串在内容中表示时也不会特别大，所以内容可以使用unicode来处理，但是存储和网络传输时一般数据都会非常多，那么增加1倍将是无法容忍的！！！  
为了解决存储和网络传输的问题，出现了Unicode Transformation Format，学术名UTF，即：对unicode中的进行转换，以便于在存储和网络传输时可以节省空间!  

- UTF-8： 使用1、2、3、4个字节表示所有字符；优先使用1个字符、无法满足则使增加一个字节，最多4个字节。英文占1个字节、欧洲语系占2个、东亚占3个，其它及特殊字符占4个  
- UTF-16： 使用2、4个字节表示所有字符；优先使用2个字节，否则使用4个字节表示。  
- UTF-32： 使用4个字节表示所有字符。  

### Python3的执行过程
在看实际代码的例子前，我们来聊聊，python3 执行代码的过程  
1. 解释器找到代码文件，把代码字符串按文件头定义的编码加载到内存，转成unicode
2. 把代码字符串按照语法规则进行解释，
3. 所有的变量字符都会以unicode编码声明

[更多详细内容](https://www.zhihu.com/question/31833164/answer/381137073)


### 字节与字符
计算机存储的一切数据，文本字符、图片、视频、音频、软件都是由一串01的字节序列构成的，一个字节等于8个比特位。  
而字符就是一个符号，比如一个汉字、一个英文字母、一个数字、一个标点符号都可以称之为字符。  
字节方便存储和网络传输，而字符用于显示，方便阅读。例如字符`p`存储到硬盘是一串二进制数据`01110000`，占用一个字节的长度。  

### 编码与解码
我们用编辑器打开的文本，看到的一个个字符，最终保存在磁盘的时候都是以二进制字节序列形式存起来的。那么从字符到字节的转换过程就叫做编码（encode），反过来叫做解码（decode），两者是一个可逆的过程。编码是为了存储传输，解码是为了方便显示阅读。  

例如字符 "p" 经过编码处理保存到硬盘是一串二进制字节序列 01110000 ，占用一个字节的长度。字符 "禅" 有可能是以 "11100111 10100110 10000101" 占用3个字节的长度存储。  


![编码与解码](https://pic3.zhimg.com/v2-417b15942a67a6a4bb1c7df2ac762253_r.jpg)


## Python中bytes、str与unicode的区别

Python 3有两种表示字符序列的类型：`bytes`和`str`。前者的实例包含原始的8位值；后者的实例包含`Unicode`字符。  
Python 3不会以任意隐式的方式混用`str`和`bytes`，你不能拼接字符串和字节流，也无法在字节流里搜索字符串（反之亦然），也不能将字符串传入参数为字节流的函数（反之亦然）。  

1. 在将字符串存入磁盘和从磁盘读取字符串的过程中，Python自动地帮你完成了编码和解码的工作，你不需要关心它的过程。
2. 使用`bytes`类型，实质上是告诉Python，不需要它帮你自动地完成编码和解码的工作，而是用户自己手动进行，并指定编码格式。
3. Python已经严格区分了`bytes`和`str`两种数据类型，你不能在需要`bytes`类型参数的时候使用`str`参数，反之亦然。这点在读写磁盘文件时容易碰到。

编写Python程序的时候，一定要把编码和解码操作放在界面的最外围来做。程序的核心部分应该使用Unicode字符类型，而且不要对字符编码做任何假设。这种办法既可以令程序接受多种类型的文本编码，又可以保证输出的文本信息只采用一种编码形式。  

所以我们需要编写两个辅助函数
```python
def to_str(bytes_or_str):
    if isintance(bytes_or_str, bytes)
        value = bytes_or_str.decode('utf-8')
    else:
        value = byter_or_str
    return value    # Instance of str
```
```python
def to_bytes(bytes_or_str):
    if isintance(bytes_or_str, str)
        value = bytes_or_str.encode('utf-8')
    else:
        value = byter_or_str
    return value    # Instance of bytes
```

如果使用内置的open函数获取了文件句柄，该句柄默认会采用UTF-8编码格式来操作文件。在对二进制数据的读写时最好使用`rb`，`wb`。 

